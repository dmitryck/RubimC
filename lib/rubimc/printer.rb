class RubimCode
	class << self
		attr_accessor :level
	end
	@level = 0
end

class << RubimCode

	# Add line in generated file and print in console
	def pout(str = "")
		if str.nil? or str.to_s.nil?
			raise ArgumentError, "str is nil"
		else
			res_str = " "*4*@level + str.to_s 
			if RubimCode::Printer.pout_destination.in? [:default, nil]
				puts res_str
				unless defined? TEST_MODE
					File.open("#{ARGV[0]}.c", 'a+') {|file| file.puts(res_str) }
				end
			elsif RubimCode::Printer.pout_destination == :h_file
				unless defined? TEST_MODE
					File.open("#{ARGV[0]}.h", 'a+') {|file| file.puts(res_str) }
				end
			else
				RubimCode::Printer.pout_destination.concat(res_str).concat("\n")
			end
		end
	end

	# Show error message in console end exit
	def perror(error_message)
		if error_message.nil? or error_message.to_s.nil? 
			raise ArgumentError, "error message is not string" 
		end

		error_message += "\n"
		code_ptr = caller_locations(2)
		code_ptr.each do |place| 
			place = place.to_s
			place.gsub!(/\/release\//, '/')
			error_message += "\tfrom #{place}\n"
		end
		puts "#ERROR: #{error_message}"
		exit 1
	end

end # RubimCode class


class RubimCode::Printer
	@@instance_vars_cc = []
	def self.instance_vars_cc
		@@instance_vars_cc
	end

	@@pout_destination = :default
	def self.pout_destination
		@@pout_destination
	end
	def self.pout_destination=(dest)
		if dest.nil?
			perror "Wrong parameter for method #{__method__}. Set destination string"
		end

		if dest.class.name == "String" or dest.in? [:default, :h_file] # dest.is_a?(String) not work...WTF
			@@pout_destination = dest
		else
			perror "Wrong parameter for method #{__method__}. Only string variable or ':default' value is permit as a parameters"
		end
	end

	# Detect type of code to compile
	def self.code_type
		if Controllers.all.any?
			"avr-gcc" 
		elsif Controllers.all.empty? and eval("self.private_methods.include? :main")
			"gcc"
		else
			RubimCode.perror "Can not define type of code"
		end
	end

	# Detect name of MCU (used as parameter for avr-gcc compiler)
	def self.mcu_type
		code_type == "avr-gcc" ? Controllers.all.first::MCU_NAME : "undefined"
	end

	def self.print_layout(position, &mcu_layout)
		basename = File.basename(ARGV[0]) # base name of compiled file
		if position == :before_main
			RubimCode::Printer.pout_destination = :h_file
			RubimCode.pout "/**************************************************************"
			RubimCode.pout " * This code was generated by RubimC micro-framework"
			RubimCode.pout " * Include file for \"#{basename}.c\""
			RubimCode.pout " **************************************************************/"

			RubimCode::Printer.pout_destination = :default
			RubimCode.pout "/**************************************************************"
			RubimCode.pout " * This code was generated by RubimC micro-framework"
			RubimCode.pout " * RubimC version: #{RubimCode::VERSION}"
			RubimCode.pout " * RubimC author: Evgeny Danilov"
			RubimCode.pout " * File created at #{Time.now}"
			RubimCode.pout " **************************************************************/"
			RubimCode.pout
			RubimCode.pout "#include <stdbool.h>"
			RubimCode.pout "#include <stdio.h>"
			RubimCode.pout
			yield if block_given? # print includes for current MCU (see mcu libraries)
			RubimCode.pout
			RubimCode.pout "#include \"#{basename}.h\""
			RubimCode.pout
			RubimCode.pout "int main(int argc, char *argv[]) {"
			RubimCode.level += 1
		else
			RubimCode.pout
			RubimCode.pout "return 1;"
			RubimCode.level -= 1
			RubimCode.pout "}"
		end
	end

	def self.print_main_loop
		RubimCode.pout
		RubimCode.pout "// === Main Infinite Loop === //"
		RubimCode.pout "while (true) {"
			RubimCode.level += 1
			yield # print body of main loop
			RubimCode.level -= 1
		RubimCode.pout"} // end main loop"
	end

	def self.print_instance_vars
		RubimCode::Printer.pout_destination = :h_file
		@@instance_vars_cc.each do |var|
			if var.is_a? RubimCode::UserVariable
				RubimCode.pout "#{var.type} #{var.name};"
			end
		end
		RubimCode::Printer.pout_destination = :default
	end

	def self.generate_cc
		exit 0 if defined? TEST_MODE

		if Controllers.all.count > 1
			RubimCode.perror "In current version in one file you can define only one Controller Class"
		end

		if self.code_type == "avr-gcc" # if compile program for MCU
			Controllers.all.each do |mcu_class|
				print_layout(:before_main) do
					mcu_class.mcu_layout if mcu_class.respond_to? :mcu_layout
				end
				mcu = mcu_class.new # print initialize section
				print_main_loop {mcu.main_loop} # print body of main loop
				print_layout(:after_main) 
				RubimCode::Interrupts.print()
				RubimCode::Printer.print_instance_vars()
			end # each Controllers.all

		elsif self.code_type == "gcc" # if compile clear-C program
			if Controllers.all.empty? and eval("self.private_methods.include? :main")
				print_layout(:before_main)
				eval("main(RubimCode::Printer::CC_ARGS.new)") # execute user`s method :main (CC_ARGS - helper for C agruments argc/argv)
				print_layout(:after_main)
			end
		end
	end

	# Class for arguments when work with clear C-code
	class CC_ARGS 
		def count
			RubimCode::UserVariable.new("argc", "int")
		end

		def [](index)
			RubimCode::UserVariable.new("argv[#{index}]", "int")
		end
	end # end CC_ARGS class

end # end RubimCode::Printer class

class RubimCode

	# Список аппаратных прерываний (содержит Си-код в текстовом виде)
	class Interrupts
		@@interrupt_array = []

		def self.array
			@@interrupt_array
		end

		def self.add(val)
			if val.class.name == "String"
				@@interrupt_array << val
			else
				RubimCode.perror "wrong params in method #{__method__}"
			end
		end

		def self.print
			@@interrupt_array.each do |interrupt_code|
				RubimCode.pout interrupt_code
				end
		end
	end # end Interrupts class
	
end # end RubimCode class